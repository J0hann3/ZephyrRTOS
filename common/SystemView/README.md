# System View

## 1. Informations
- Memory:
    - Need less than 2kB of ROM
    - About 600 bytes of RAM
- Need a Jlink 
- More documentations:
    - [Download System View Application](https://www.segger.com/downloads/systemview/)
    - [Guide for No OS application](https://kb.segger.com/Use_SystemView_without_RTOS)
    - [Official datasheet](https://www.segger.com/downloads/jlink/UM08027_SystemView.pdf)
- If SystemView doesn't work, check if RTT works

## 2. Setup
- Create a file named `SYSVIEW_Config.h` in a folder `SystemView`: In this file, define the following macros:
    - `SYSVIEW_APP_NAME`        => Name of the SystemView application
    - `SYSVIEW_PROJECT_NAME`    => Name of the project, specify in the script via the option `-P`, use to find the right file description to use.
    - `SYSVIEW_DEVICE_NAME`     => Name of the device
    - `SYSVIEW_TIMESTAMP_FREQ`  => Frequency of the timestamp in Hz
    - `SYSVIEW_CPU_FREQ`        => Frequency of the CPU in Hz (ex: value of `SystemCoreClock`)
    - `SYSVIEW_RAM_BASE`        => The lowest RAM address used for IDs (pointers)  (ex: `(0x10000000)`)  
Optionally, you can also add the following macros:
    - `SEGGER_SYSVIEW_GET_TIMESTAMP` => Name of the function used to get the timestamp value in ticks, by default  ` U32 SEGGER_SYSVIEW_X_GetTimestamp()`
    - `SEGGER_SYSVIEW_GET_INTERRUPT_ID` => Name of the function used to get the interrupt ID, by default `U32 SEGGER_SYSVIEW_X_GetInterruptId()`
    - Or any macro present in `SEGGER_SYSVIEW_ConfDefaults.h` that needs to be modified
- Create a file to initialize the chosen source of timestamp
    - For example: 
        - NxG Long, I use TC6 on 32 bits with gclk5 as a clock source at 32kHz. It wakes up every 10s and has a precision of 30us.
        - Cozy, I use a GPT0 on 32 bits with a frequency of 48MHz. It wakes up every 10s and has a precision of 21ns.

    - Each time the timer overflows, a variable needs to be incremented
    - `SEGGER_SYSVIEW_X_GetTimestamp` function will return this variable multiplied by the cycles per tick plus the current cycles.
    - The timer must be initialized  and started  before calling `DEBUG_SEGGER_SYSVIEW_Conf`
    - Warning: if interrupts are disabled, the counter will not be incremented, so `SEGGER_SYSVIEW_X_GetTimestamp` will return a value smaller than the last one, and SystemView will think the integer has overflowed and jump in time.
    - The interrupt will wake up the mcu, if it's the only source of wake up. The mcu should be put back to sleep.

- Create a json file containing all the events you want to record, then call the python script to generate the header file and file description. Don't forget to add the json file present in this directory as well as your own. The option `-P` for the script should be the same as `SYSVIEW_PROJECT_NAME`. Include the file generated by the script in `SYSVIEW_Config.h`

- At the beginning of the main, after the Mcu and board init, add the macro `DEBUG_SEGGER_SYSVIEW_Conf()`. You can also add `DEBUG_SEGGER_SYSVIEW_Start()` if you want to immediately start recording events, otherwise it will start recording when you press the "Start Record" button on the SystemView application.

- Define the symbol `SEGGER_SYSTEM_VIEW` to enable SystemView functionality, otherwise  all the macros `DEBUG_SEGGER_SYSVIEW...` will be defined to an empty value.

## 2. Instrument the code

### Record events

To record an event, use the following macros:
```c
#include <utils/SystemView/SEGGER/SEGGER_SYSVIEW.h>

DEBUG_SEGGER_SYSVIEW_RecordXX(ID_SYSVIEW_FUNCTION, XX, XX, ...);
```
- XX represents the number or type of arguments to pass to SystemView, according to its definition in the .json files.

If the event has a return value, call the following function at the end of the event:
```c
DEBUG_SEGGER_SYSVIEW_RecordEndCallXX(ID_SYSVIEW_FUNCTION, XX);
```

You can also use the following macro instead:
```c
record_sysview_<FunctionName>(XX, ...);
```
- `XX` represents the number or type of arguments to pass to SystemView, according to its definition in the json files.
- `<FunctionName>` is the name of the function in the json file


Functions that have a return description must be called like this:
```c
#include <utils/SystemView/SEGGER/SEGGER_SYSVIEW.h>

record_sysview_<FunctionName>_enter(XX, ...);
function_to_record();
record_sysview_<FunctionName>_exit(XX)
```

### Named Type
If an event description or return description has a NameType value, ex: "Return %OSError", pass the NamedType value to the record function `DEBUG_SEGGER_SYSVIEW_RecordXX(ID_SYSVIEW_name, TYPE_SYSVIEW_xx)`.

Ex: `DEBUG_SEGGER_SYSVIEW_RecordU32(ID_SYSVIEW_MEASURE_LIGHT, TYPE_SYSVIEW_OSERROR_SUCCESS)`

### Tasks
#### Add task
To add a new task definition, call the following function:
```c
#include "utils/SystemView/SEGGER/SEGGER_SYSVIEW.h"

DEBUG_SYSVIEW_AddTask(blink_led_function, "blink_led", 0);
```
- `blink_led_function`(void *) is a function pointer, it will be the ID of the task. It will be converted to an uint32_t.
- `"blink_led"`(char *) is the name of the new task.
- `0`(uint32_t) is the priority of the task, not really useful for a no-OS application.

#### Record task
To record the task, use the following macros:
```c
DEBUG_SEGGER_SYSVIEW_OnIdle                        (void);               // Go to sleep
DEBUG_SEGGER_SYSVIEW_OnTaskTerminate               (U32 TaskId);
DEBUG_SEGGER_SYSVIEW_OnTaskStartExec               (U32 TaskId);         // Start executing a new task
DEBUG_SEGGER_SYSVIEW_OnTaskStopExec                (void);               // Stop a task, the scheduler task starts until a new task starts
DEBUG_SEGGER_SYSVIEW_OnTaskStartReady              (U32 TaskId);
DEBUG_SEGGER_SYSVIEW_OnTaskStopReady               (U32 TaskId, unsigned int Cause);
```
- `U32 TaskId` is the first argument passed to the function `DEBUG_SYSVIEW_AddTask` previously.

By default, the main function is considered as the idle task. To change this, you need to create a task called main, then call the macro `DEBUG_SEGGER_SYSVIEW_OnTaskStartExec(main)`.

To define the maximum number of tasks, there is a define `SYSVIEW_NUM_TASKS`, currently set to 16, but can be redefined with another value. An array of this size is created to store the tasks.

### Data Plot
#### Register Data Plot

To register data to track in a graph use the following function:
```c
#include "utils/SystemView/SEGGER/SEGGER_SYSVIEW.h"

DEBUG_SYSVIEW_AddDataRegister(TEMP_ID, "temperature", SEGGER_SYSVIEW_TYPE_FLOAT, "°C");
```
- `TEMP_ID`(uint32_t) is the ID of the data to register, will be use to send the data.
- `"temperature"`(char *) is the name of the data register.
- `SEGGER_SYSVIEW_TYPE_FLOAT`(enum) is the type of data register, can be `SEGGER_SYSVIEW_TYPE_U32, SEGGER_SYSVIEW_TYPE_I32, SEGGER_SYSVIEW_TYPE_FLOAT`.
- `"°C"`(char *) is the name of the measure unit.

#### Send Data Plot

To send data use the following function:
```c
#include "utils/SystemView/SEGGER/SEGGER_SYSVIEW.h"

float float_temperature = 25.06;            // Data to register

SEGGER_SYSVIEW_DATA_SAMPLE var;
var.ID            = TEMP_ID;
var.pValue.pFloat = &float_temperature;    //if the type is other then float use pI32 or pU32
DEBUG_SEGGER_SYSVIEW_SampleData(&var);
```

To define the maximum number of data registers, there is a define `SYSVIEW_NUM_DATA_REGISTER`, currently set to 16, but it can be redefined with another value. An array of the size is created to store all the data registers.
 
### Terminal
System View has its own terminal using RTT. The messages printed can be a normal print or a warning, or an error message.
You can use the following macros in your code to print in the terminal.
```c
#ifndef SEGGER_SYSVIEW_EXCLUDE_PRINTF // Define in project to avoid warnings about variable parameter list
DEBUG_SEGGER_SYSVIEW_PrintfHostEx                  (const char* s, U32 Options, ...);
DEBUG_SEGGER_SYSVIEW_VPrintfHostEx                 (const char* s, U32 Options, va_list* pParamList);
DEBUG_SEGGER_SYSVIEW_PrintfTargetEx                (const char* s, U32 Options, ...);
DEBUG_SEGGER_SYSVIEW_VPrintfTargetEx               (const char* s, U32 Options, va_list* pParamList);
DEBUG_SEGGER_SYSVIEW_PrintfHost                    (const char* s, ...);
DEBUG_SEGGER_SYSVIEW_VPrintfHost                   (const char* s, va_list* pParamList);
DEBUG_SEGGER_SYSVIEW_PrintfTarget                  (const char* s, ...);
DEBUG_SEGGER_SYSVIEW_VPrintfTarget                 (const char* s, va_list* pParamList);
DEBUG_SEGGER_SYSVIEW_WarnfHost                     (const char* s, ...);
DEBUG_SEGGER_SYSVIEW_VWarnfHost                    (const char* s, va_list* pParamList);
DEBUG_SEGGER_SYSVIEW_WarnfTarget                   (const char* s, ...);
DEBUG_SEGGER_SYSVIEW_VWarnfTarget                  (const char* s, va_list* pParamList);
DEBUG_SEGGER_SYSVIEW_ErrorfHost                    (const char* s, ...);
DEBUG_SEGGER_SYSVIEW_VErrorfHost                   (const char* s, va_list* pParamList);
DEBUG_SEGGER_SYSVIEW_ErrorfTarget                  (const char* s, ...);
DEBUG_SEGGER_SYSVIEW_VErrorfTarget                 (const char* s, va_list* pParamList);
#endif

DEBUG_SEGGER_SYSVIEW_Print                         (const char* s);
DEBUG_SEGGER_SYSVIEW_Warn                          (const char* s);
DEBUG_SEGGER_SYSVIEW_Error                         (const char* s);
```

For `printf` with varg it's possible to choose if it's formatted on the target or on the host.  
If it's formatted on the host, it will take all the arguments and transfer them as a `uint32_t`, so it will be undefined to pass strings as arguments.  
If it's formatted on the target, it will support 'c', 'd', 'u', 'x', 'X', 's', 'p', '%', 'l', 'h', '-', '0', '+', '#' and '.'.

### Name ISR

To give a name to the ISR, you can implement the following function:

```c
void _cbSendIsrName(void)
{
    DEBUG_SEGGER_SYSVIEW_SendSysDesc("I#15=SysTick, I#16=Gpt, I#32=Wdt");
}
```
 - `15`, `16`, `32` are the exception numbers in the vector table. The first 15 are reserved by ARM, the others are defined by the constructor.
    - For example, on the SAMD21, the watchdog is the IRQ2, so its exception number is 18, because IRQ0 is the first non-reserved interrupt by ARM, which is number 16. You need to add an offset of 16 to the Table 11-3, representing the interrupt mapping for the SAMD21

    <img width="353" height="445" alt="image" src="https://documentation-service.arm.com/static/5f04abc8dbdee951c1cdc9ec?token=" />

 - `SysTick`, `Gpt`, `Wdt` are the names given to the interrupt.

You can define as many interrupts as you want. If you don't need to, you don't have to define this function.

Warning: You don't have to call this function manually, it will be alled automatically when starting recording on SystemView.

## 3. Build the project
### e2studio

To automate the build process by running the script to generate the header file and file description for SystemView, in e2studio you can go to Project -> C/C++ Project Settings -> Settings -> Build Steps. In Pre-build command(s) add the command to run. 
- You can either write the script command directly, but the file will be regenerated at each build. 
- Or, create a makefile that runs the script with dependencies, like the json file. The `Makefile.sample` must be placed in the `SystemView` directory created previously. The command to run is the following: `make all -C ..\src\SystemView`, `all` is the name of the rule to use, and `-C` specifies the path to the Makefile directory.

Warning: if the pre-build command fails, e2studio continues to build the project. But the error appears in the problems window or at the beginning of the console window.

### Meson build

In your meson.build file add the following:

```
sysview_json_files = ['S137\peripherals_SAMD21\SystemView\SysView.json', 'S137\SystemView\SystemView.json']
sysview_python_script = files('S137\peripherals_SAMD21\SystemView\generate_sysview_os_file.py')

system_view = custom_target(
    'system_view',
    input: sysview_json_files,
    output: 'SEGGER_SYSVIEW_Conf.g.h',
    depend_files: sysview_json_files,
    command: ['python', sysview_python_script, '-O', 'NoOS_NxgLong', '-j', '@INPUT@', '-pH', './', '-pA'],
)

system_view_dep = declare_dependency(sources: system_view)
```

And in the rule to build the executable, add `system_view_dep` as a `dependencies`.

## 4. Sleep mode
### Renesas ra2l1

On the board ek-ra2l1, when starting recording on SystemView, a debug session will start. If the mcu was in standbymode it will put it in sleep mode instead, and restart it.

## 5. RTT

To use RTT define the following macro with the size of the RTT buffer:
```c
#define BUFFER_SIZE_UP 1024     // For terminal output
#define BUFFER_SIZE_DOWN 16     // For terminal input
```

To redirect printf to RTT instead of uart define the following symbol `RTT_PRINTF`.